
RTC.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000088a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000ca  00800060  0000088a  0000091e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000000f  0080012a  0080012a  000009e8  2**0
                  ALLOC
  3 .stab         000006cc  00000000  00000000  000009e8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000085  00000000  00000000  000010b4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000060  00000000  00000000  00001139  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001bb  00000000  00000000  00001199  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00000518  00000000  00000000  00001354  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000248  00000000  00000000  0000186c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000818  00000000  00000000  00001ab4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000180  00000000  00000000  000022cc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000001e6  00000000  00000000  0000244c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_pubtypes 00000057  00000000  00000000  00002632  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	11 e0       	ldi	r17, 0x01	; 1
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	ea e8       	ldi	r30, 0x8A	; 138
  68:	f8 e0       	ldi	r31, 0x08	; 8
  6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0
  70:	aa 32       	cpi	r26, 0x2A	; 42
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
  76:	11 e0       	ldi	r17, 0x01	; 1
  78:	aa e2       	ldi	r26, 0x2A	; 42
  7a:	b1 e0       	ldi	r27, 0x01	; 1
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a9 33       	cpi	r26, 0x39	; 57
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 1e 03 	call	0x63c	; 0x63c <main>
  8a:	0c 94 43 04 	jmp	0x886	; 0x886 <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <uart_write_time>:
/********************TWI SECTION********************************************/

/**************************************RTC section***********************************/

void uart_write_time()                                         //function to write the decoded time into the uart
{
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	0f 92       	push	r0
  98:	cd b7       	in	r28, 0x3d	; 61
  9a:	de b7       	in	r29, 0x3e	; 62
	signed char i;
	for(i=2;i>=0;i--)                                         //writes sec,min,hr
  9c:	82 e0       	ldi	r24, 0x02	; 2
  9e:	89 83       	std	Y+1, r24	; 0x01
  a0:	28 c0       	rjmp	.+80     	; 0xf2 <uart_write_time+0x60>
	{
	write_uart((current_time.time[i]/10)+48);
  a2:	89 81       	ldd	r24, Y+1	; 0x01
  a4:	99 27       	eor	r25, r25
  a6:	87 fd       	sbrc	r24, 7
  a8:	90 95       	com	r25
  aa:	8f 5c       	subi	r24, 0xCF	; 207
  ac:	9e 4f       	sbci	r25, 0xFE	; 254
  ae:	fc 01       	movw	r30, r24
  b0:	80 81       	ld	r24, Z
  b2:	9a e0       	ldi	r25, 0x0A	; 10
  b4:	69 2f       	mov	r22, r25
  b6:	0e 94 37 04 	call	0x86e	; 0x86e <__udivmodqi4>
  ba:	80 5d       	subi	r24, 0xD0	; 208
  bc:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
	write_uart((current_time.time[i]%10)+48);
  c0:	89 81       	ldd	r24, Y+1	; 0x01
  c2:	99 27       	eor	r25, r25
  c4:	87 fd       	sbrc	r24, 7
  c6:	90 95       	com	r25
  c8:	8f 5c       	subi	r24, 0xCF	; 207
  ca:	9e 4f       	sbci	r25, 0xFE	; 254
  cc:	fc 01       	movw	r30, r24
  ce:	80 81       	ld	r24, Z
  d0:	9a e0       	ldi	r25, 0x0A	; 10
  d2:	69 2f       	mov	r22, r25
  d4:	0e 94 37 04 	call	0x86e	; 0x86e <__udivmodqi4>
  d8:	89 2f       	mov	r24, r25
  da:	80 5d       	subi	r24, 0xD0	; 208
  dc:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
	if(i>0)
  e0:	89 81       	ldd	r24, Y+1	; 0x01
  e2:	18 16       	cp	r1, r24
  e4:	1c f4       	brge	.+6      	; 0xec <uart_write_time+0x5a>
	write_uart(':');
  e6:	8a e3       	ldi	r24, 0x3A	; 58
  e8:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
/**************************************RTC section***********************************/

void uart_write_time()                                         //function to write the decoded time into the uart
{
	signed char i;
	for(i=2;i>=0;i--)                                         //writes sec,min,hr
  ec:	89 81       	ldd	r24, Y+1	; 0x01
  ee:	81 50       	subi	r24, 0x01	; 1
  f0:	89 83       	std	Y+1, r24	; 0x01
  f2:	89 81       	ldd	r24, Y+1	; 0x01
  f4:	88 23       	and	r24, r24
  f6:	ac f6       	brge	.-86     	; 0xa2 <uart_write_time+0x10>
	write_uart((current_time.time[i]%10)+48);
	if(i>0)
	write_uart(':');
	}
	
	write_uart_strg("   ");                                //checking the global am,pm flag and writes am or pm
  f8:	8a e8       	ldi	r24, 0x8A	; 138
  fa:	90 e0       	ldi	r25, 0x00	; 0
  fc:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
	if(!am)
 100:	80 91 38 01 	lds	r24, 0x0138
 104:	88 23       	and	r24, r24
 106:	29 f4       	brne	.+10     	; 0x112 <uart_write_time+0x80>
	write_uart_strg("pm");
 108:	8e e8       	ldi	r24, 0x8E	; 142
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
 110:	08 c0       	rjmp	.+16     	; 0x122 <uart_write_time+0x90>
	else if(am)
 112:	80 91 38 01 	lds	r24, 0x0138
 116:	88 23       	and	r24, r24
 118:	21 f0       	breq	.+8      	; 0x122 <uart_write_time+0x90>
	write_uart_strg("am");
 11a:	81 e9       	ldi	r24, 0x91	; 145
 11c:	90 e0       	ldi	r25, 0x00	; 0
 11e:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
	
	write_uart_strg("   ");
 122:	8a e8       	ldi	r24, 0x8A	; 138
 124:	90 e0       	ldi	r25, 0x00	; 0
 126:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
	write_uart_strg(day[(current_time.date[0])-1]);        //writes day eg:mon,sun
 12a:	80 91 34 01 	lds	r24, 0x0134
 12e:	88 2f       	mov	r24, r24
 130:	90 e0       	ldi	r25, 0x00	; 0
 132:	01 97       	sbiw	r24, 0x01	; 1
 134:	88 0f       	add	r24, r24
 136:	99 1f       	adc	r25, r25
 138:	84 58       	subi	r24, 0x84	; 132
 13a:	9f 4f       	sbci	r25, 0xFF	; 255
 13c:	fc 01       	movw	r30, r24
 13e:	80 81       	ld	r24, Z
 140:	91 81       	ldd	r25, Z+1	; 0x01
 142:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
	write_uart_strg("   ");
 146:	8a e8       	ldi	r24, 0x8A	; 138
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
	
	for(i=1;i<=3;i++)                                       //writes the date,month ,year
 14e:	81 e0       	ldi	r24, 0x01	; 1
 150:	89 83       	std	Y+1, r24	; 0x01
 152:	28 c0       	rjmp	.+80     	; 0x1a4 <uart_write_time+0x112>
	{
		write_uart((current_time.date[i]/10)+48);
 154:	89 81       	ldd	r24, Y+1	; 0x01
 156:	99 27       	eor	r25, r25
 158:	87 fd       	sbrc	r24, 7
 15a:	90 95       	com	r25
 15c:	8c 5c       	subi	r24, 0xCC	; 204
 15e:	9e 4f       	sbci	r25, 0xFE	; 254
 160:	fc 01       	movw	r30, r24
 162:	80 81       	ld	r24, Z
 164:	9a e0       	ldi	r25, 0x0A	; 10
 166:	69 2f       	mov	r22, r25
 168:	0e 94 37 04 	call	0x86e	; 0x86e <__udivmodqi4>
 16c:	80 5d       	subi	r24, 0xD0	; 208
 16e:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
		write_uart((current_time.date[i]%10)+48);
 172:	89 81       	ldd	r24, Y+1	; 0x01
 174:	99 27       	eor	r25, r25
 176:	87 fd       	sbrc	r24, 7
 178:	90 95       	com	r25
 17a:	8c 5c       	subi	r24, 0xCC	; 204
 17c:	9e 4f       	sbci	r25, 0xFE	; 254
 17e:	fc 01       	movw	r30, r24
 180:	80 81       	ld	r24, Z
 182:	9a e0       	ldi	r25, 0x0A	; 10
 184:	69 2f       	mov	r22, r25
 186:	0e 94 37 04 	call	0x86e	; 0x86e <__udivmodqi4>
 18a:	89 2f       	mov	r24, r25
 18c:	80 5d       	subi	r24, 0xD0	; 208
 18e:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
		if(i<3)
 192:	89 81       	ldd	r24, Y+1	; 0x01
 194:	83 30       	cpi	r24, 0x03	; 3
 196:	1c f4       	brge	.+6      	; 0x19e <uart_write_time+0x10c>
		write_uart(':');
 198:	8a e3       	ldi	r24, 0x3A	; 58
 19a:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
	
	write_uart_strg("   ");
	write_uart_strg(day[(current_time.date[0])-1]);        //writes day eg:mon,sun
	write_uart_strg("   ");
	
	for(i=1;i<=3;i++)                                       //writes the date,month ,year
 19e:	89 81       	ldd	r24, Y+1	; 0x01
 1a0:	8f 5f       	subi	r24, 0xFF	; 255
 1a2:	89 83       	std	Y+1, r24	; 0x01
 1a4:	89 81       	ldd	r24, Y+1	; 0x01
 1a6:	84 30       	cpi	r24, 0x04	; 4
 1a8:	ac f2       	brlt	.-86     	; 0x154 <uart_write_time+0xc2>
		write_uart((current_time.date[i]/10)+48);
		write_uart((current_time.date[i]%10)+48);
		if(i<3)
		write_uart(':');
	}
	write_uart_strg("\n\r");
 1aa:	84 e9       	ldi	r24, 0x94	; 148
 1ac:	90 e0       	ldi	r25, 0x00	; 0
 1ae:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
}
 1b2:	0f 90       	pop	r0
 1b4:	cf 91       	pop	r28
 1b6:	df 91       	pop	r29
 1b8:	08 95       	ret

000001ba <decode_date>:

void decode_date()                                            //decode date from BCD to DEC
{
 1ba:	df 93       	push	r29
 1bc:	cf 93       	push	r28
 1be:	0f 92       	push	r0
 1c0:	cd b7       	in	r28, 0x3d	; 61
 1c2:	de b7       	in	r29, 0x3e	; 62
	unsigned char i=0;
 1c4:	19 82       	std	Y+1, r1	; 0x01
	while(i<4)
 1c6:	22 c0       	rjmp	.+68     	; 0x20c <decode_date+0x52>
	{
		current_time.date[i]=((current_time.date[i]>>4)*10)+(current_time.date[i]&0x0F);
 1c8:	89 81       	ldd	r24, Y+1	; 0x01
 1ca:	88 2f       	mov	r24, r24
 1cc:	90 e0       	ldi	r25, 0x00	; 0
 1ce:	29 81       	ldd	r18, Y+1	; 0x01
 1d0:	22 2f       	mov	r18, r18
 1d2:	30 e0       	ldi	r19, 0x00	; 0
 1d4:	2c 5c       	subi	r18, 0xCC	; 204
 1d6:	3e 4f       	sbci	r19, 0xFE	; 254
 1d8:	f9 01       	movw	r30, r18
 1da:	20 81       	ld	r18, Z
 1dc:	22 95       	swap	r18
 1de:	2f 70       	andi	r18, 0x0F	; 15
 1e0:	22 0f       	add	r18, r18
 1e2:	32 2f       	mov	r19, r18
 1e4:	33 0f       	add	r19, r19
 1e6:	33 0f       	add	r19, r19
 1e8:	42 2f       	mov	r20, r18
 1ea:	43 0f       	add	r20, r19
 1ec:	29 81       	ldd	r18, Y+1	; 0x01
 1ee:	22 2f       	mov	r18, r18
 1f0:	30 e0       	ldi	r19, 0x00	; 0
 1f2:	2c 5c       	subi	r18, 0xCC	; 204
 1f4:	3e 4f       	sbci	r19, 0xFE	; 254
 1f6:	f9 01       	movw	r30, r18
 1f8:	20 81       	ld	r18, Z
 1fa:	2f 70       	andi	r18, 0x0F	; 15
 1fc:	24 0f       	add	r18, r20
 1fe:	8c 5c       	subi	r24, 0xCC	; 204
 200:	9e 4f       	sbci	r25, 0xFE	; 254
 202:	fc 01       	movw	r30, r24
 204:	20 83       	st	Z, r18
		i++;
 206:	89 81       	ldd	r24, Y+1	; 0x01
 208:	8f 5f       	subi	r24, 0xFF	; 255
 20a:	89 83       	std	Y+1, r24	; 0x01
}

void decode_date()                                            //decode date from BCD to DEC
{
	unsigned char i=0;
	while(i<4)
 20c:	89 81       	ldd	r24, Y+1	; 0x01
 20e:	84 30       	cpi	r24, 0x04	; 4
 210:	d8 f2       	brcs	.-74     	; 0x1c8 <decode_date+0xe>
	{
		current_time.date[i]=((current_time.date[i]>>4)*10)+(current_time.date[i]&0x0F);
		i++;
	}
	uart_write_time();                          // fn call to write time and date(decoded)
 212:	0e 94 49 00 	call	0x92	; 0x92 <uart_write_time>
}
 216:	0f 90       	pop	r0
 218:	cf 91       	pop	r28
 21a:	df 91       	pop	r29
 21c:	08 95       	ret

0000021e <decode_time>:


void decode_time()                               //decodes the time from           
{
 21e:	df 93       	push	r29
 220:	cf 93       	push	r28
 222:	0f 92       	push	r0
 224:	cd b7       	in	r28, 0x3d	; 61
 226:	de b7       	in	r29, 0x3e	; 62
unsigned char i=0;
 228:	19 82       	std	Y+1, r1	; 0x01
while(i<3)	
 22a:	86 c0       	rjmp	.+268    	; 0x338 <decode_time+0x11a>
{
if(i<2)                                               //BCD-DEC for sec and min reg
 22c:	89 81       	ldd	r24, Y+1	; 0x01
 22e:	82 30       	cpi	r24, 0x02	; 2
 230:	00 f5       	brcc	.+64     	; 0x272 <decode_time+0x54>
current_time.time[i]=((current_time.time[i]>>4)*10)+(current_time.time[i]&0x0F);
 232:	89 81       	ldd	r24, Y+1	; 0x01
 234:	88 2f       	mov	r24, r24
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	29 81       	ldd	r18, Y+1	; 0x01
 23a:	22 2f       	mov	r18, r18
 23c:	30 e0       	ldi	r19, 0x00	; 0
 23e:	2f 5c       	subi	r18, 0xCF	; 207
 240:	3e 4f       	sbci	r19, 0xFE	; 254
 242:	f9 01       	movw	r30, r18
 244:	20 81       	ld	r18, Z
 246:	22 95       	swap	r18
 248:	2f 70       	andi	r18, 0x0F	; 15
 24a:	22 0f       	add	r18, r18
 24c:	32 2f       	mov	r19, r18
 24e:	33 0f       	add	r19, r19
 250:	33 0f       	add	r19, r19
 252:	42 2f       	mov	r20, r18
 254:	43 0f       	add	r20, r19
 256:	29 81       	ldd	r18, Y+1	; 0x01
 258:	22 2f       	mov	r18, r18
 25a:	30 e0       	ldi	r19, 0x00	; 0
 25c:	2f 5c       	subi	r18, 0xCF	; 207
 25e:	3e 4f       	sbci	r19, 0xFE	; 254
 260:	f9 01       	movw	r30, r18
 262:	20 81       	ld	r18, Z
 264:	2f 70       	andi	r18, 0x0F	; 15
 266:	24 0f       	add	r18, r20
 268:	8f 5c       	subi	r24, 0xCF	; 207
 26a:	9e 4f       	sbci	r25, 0xFE	; 254
 26c:	fc 01       	movw	r30, r24
 26e:	20 83       	st	Z, r18
 270:	60 c0       	rjmp	.+192    	; 0x332 <decode_time+0x114>

else                  //hr reg
{
if(current_time.time[i]&(1<<6))                             //if 12 hr mode
 272:	89 81       	ldd	r24, Y+1	; 0x01
 274:	88 2f       	mov	r24, r24
 276:	90 e0       	ldi	r25, 0x00	; 0
 278:	8f 5c       	subi	r24, 0xCF	; 207
 27a:	9e 4f       	sbci	r25, 0xFE	; 254
 27c:	fc 01       	movw	r30, r24
 27e:	80 81       	ld	r24, Z
 280:	88 2f       	mov	r24, r24
 282:	90 e0       	ldi	r25, 0x00	; 0
 284:	80 74       	andi	r24, 0x40	; 64
 286:	90 70       	andi	r25, 0x00	; 0
 288:	00 97       	sbiw	r24, 0x00	; 0
 28a:	a1 f1       	breq	.+104    	; 0x2f4 <decode_time+0xd6>
{
if(current_time.time[i]&(1<<5))                            //if PM
 28c:	89 81       	ldd	r24, Y+1	; 0x01
 28e:	88 2f       	mov	r24, r24
 290:	90 e0       	ldi	r25, 0x00	; 0
 292:	8f 5c       	subi	r24, 0xCF	; 207
 294:	9e 4f       	sbci	r25, 0xFE	; 254
 296:	fc 01       	movw	r30, r24
 298:	80 81       	ld	r24, Z
 29a:	88 2f       	mov	r24, r24
 29c:	90 e0       	ldi	r25, 0x00	; 0
 29e:	80 72       	andi	r24, 0x20	; 32
 2a0:	90 70       	andi	r25, 0x00	; 0
 2a2:	00 97       	sbiw	r24, 0x00	; 0
 2a4:	19 f0       	breq	.+6      	; 0x2ac <decode_time+0x8e>
am=0;                                                     //global flag to identfy am,pm mode
 2a6:	10 92 38 01 	sts	0x0138, r1
 2aa:	03 c0       	rjmp	.+6      	; 0x2b2 <decode_time+0x94>
else
am=1;
 2ac:	81 e0       	ldi	r24, 0x01	; 1
 2ae:	80 93 38 01 	sts	0x0138, r24

current_time.time[i]=(((current_time.time[i]>>4)&0x01)*10)+(current_time.time[i]&0x0F);	  //BCD-DEC clear 12hr mode bit and am,pm bit   
 2b2:	89 81       	ldd	r24, Y+1	; 0x01
 2b4:	88 2f       	mov	r24, r24
 2b6:	90 e0       	ldi	r25, 0x00	; 0
 2b8:	29 81       	ldd	r18, Y+1	; 0x01
 2ba:	22 2f       	mov	r18, r18
 2bc:	30 e0       	ldi	r19, 0x00	; 0
 2be:	2f 5c       	subi	r18, 0xCF	; 207
 2c0:	3e 4f       	sbci	r19, 0xFE	; 254
 2c2:	f9 01       	movw	r30, r18
 2c4:	20 81       	ld	r18, Z
 2c6:	22 95       	swap	r18
 2c8:	2f 70       	andi	r18, 0x0F	; 15
 2ca:	21 70       	andi	r18, 0x01	; 1
 2cc:	22 0f       	add	r18, r18
 2ce:	32 2f       	mov	r19, r18
 2d0:	33 0f       	add	r19, r19
 2d2:	33 0f       	add	r19, r19
 2d4:	42 2f       	mov	r20, r18
 2d6:	43 0f       	add	r20, r19
 2d8:	29 81       	ldd	r18, Y+1	; 0x01
 2da:	22 2f       	mov	r18, r18
 2dc:	30 e0       	ldi	r19, 0x00	; 0
 2de:	2f 5c       	subi	r18, 0xCF	; 207
 2e0:	3e 4f       	sbci	r19, 0xFE	; 254
 2e2:	f9 01       	movw	r30, r18
 2e4:	20 81       	ld	r18, Z
 2e6:	2f 70       	andi	r18, 0x0F	; 15
 2e8:	24 0f       	add	r18, r20
 2ea:	8f 5c       	subi	r24, 0xCF	; 207
 2ec:	9e 4f       	sbci	r25, 0xFE	; 254
 2ee:	fc 01       	movw	r30, r24
 2f0:	20 83       	st	Z, r18
 2f2:	1f c0       	rjmp	.+62     	; 0x332 <decode_time+0x114>
}
else
current_time.time[i]=((current_time.time[i]>>4)*10)+(current_time.time[i]&0x0F);    //if 24 hr mode BCD-DEC hr
 2f4:	89 81       	ldd	r24, Y+1	; 0x01
 2f6:	88 2f       	mov	r24, r24
 2f8:	90 e0       	ldi	r25, 0x00	; 0
 2fa:	29 81       	ldd	r18, Y+1	; 0x01
 2fc:	22 2f       	mov	r18, r18
 2fe:	30 e0       	ldi	r19, 0x00	; 0
 300:	2f 5c       	subi	r18, 0xCF	; 207
 302:	3e 4f       	sbci	r19, 0xFE	; 254
 304:	f9 01       	movw	r30, r18
 306:	20 81       	ld	r18, Z
 308:	22 95       	swap	r18
 30a:	2f 70       	andi	r18, 0x0F	; 15
 30c:	22 0f       	add	r18, r18
 30e:	32 2f       	mov	r19, r18
 310:	33 0f       	add	r19, r19
 312:	33 0f       	add	r19, r19
 314:	42 2f       	mov	r20, r18
 316:	43 0f       	add	r20, r19
 318:	29 81       	ldd	r18, Y+1	; 0x01
 31a:	22 2f       	mov	r18, r18
 31c:	30 e0       	ldi	r19, 0x00	; 0
 31e:	2f 5c       	subi	r18, 0xCF	; 207
 320:	3e 4f       	sbci	r19, 0xFE	; 254
 322:	f9 01       	movw	r30, r18
 324:	20 81       	ld	r18, Z
 326:	2f 70       	andi	r18, 0x0F	; 15
 328:	24 0f       	add	r18, r20
 32a:	8f 5c       	subi	r24, 0xCF	; 207
 32c:	9e 4f       	sbci	r25, 0xFE	; 254
 32e:	fc 01       	movw	r30, r24
 330:	20 83       	st	Z, r18
}
i++;
 332:	89 81       	ldd	r24, Y+1	; 0x01
 334:	8f 5f       	subi	r24, 0xFF	; 255
 336:	89 83       	std	Y+1, r24	; 0x01


void decode_time()                               //decodes the time from           
{
unsigned char i=0;
while(i<3)	
 338:	89 81       	ldd	r24, Y+1	; 0x01
 33a:	83 30       	cpi	r24, 0x03	; 3
 33c:	08 f4       	brcc	.+2      	; 0x340 <decode_time+0x122>
 33e:	76 cf       	rjmp	.-276    	; 0x22c <decode_time+0xe>
else
current_time.time[i]=((current_time.time[i]>>4)*10)+(current_time.time[i]&0x0F);    //if 24 hr mode BCD-DEC hr
}
i++;
}
decode_date();	                  //fn call to decode the date
 340:	0e 94 dd 00 	call	0x1ba	; 0x1ba <decode_date>
}
 344:	0f 90       	pop	r0
 346:	cf 91       	pop	r28
 348:	df 91       	pop	r29
 34a:	08 95       	ret

0000034c <RTC_write_mode>:


void RTC_write_mode()                                //access RTC in write mode with sec reg address pointed
{
 34c:	df 93       	push	r29
 34e:	cf 93       	push	r28
 350:	cd b7       	in	r28, 0x3d	; 61
 352:	de b7       	in	r29, 0x3e	; 62
	TWI_send(0xD0);                                 //slave address RTC
 354:	80 ed       	ldi	r24, 0xD0	; 208
 356:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
	TWI_send(0x00);
 35a:	80 e0       	ldi	r24, 0x00	; 0
 35c:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
	
}
 360:	cf 91       	pop	r28
 362:	df 91       	pop	r29
 364:	08 95       	ret

00000366 <RTC_write_pointer_read_mode>:

void RTC_write_pointer_read_mode()                      //access RTC with sec pointed in read mode
{
 366:	df 93       	push	r29
 368:	cf 93       	push	r28
 36a:	cd b7       	in	r28, 0x3d	; 61
 36c:	de b7       	in	r29, 0x3e	; 62
TWI_start();
 36e:	0e 94 7f 03 	call	0x6fe	; 0x6fe <TWI_start>
RTC_write_mode();
 372:	0e 94 a6 01 	call	0x34c	; 0x34c <RTC_write_mode>
TWI_start();
 376:	0e 94 7f 03 	call	0x6fe	; 0x6fe <TWI_start>
TWI_send(0xD1);	                                        //slave address with read mode
 37a:	81 ed       	ldi	r24, 0xD1	; 209
 37c:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
}
 380:	cf 91       	pop	r28
 382:	df 91       	pop	r29
 384:	08 95       	ret

00000386 <write_hour>:



void write_hour()
{
 386:	df 93       	push	r29
 388:	cf 93       	push	r28
 38a:	00 d0       	rcall	.+0      	; 0x38c <write_hour+0x6>
 38c:	0f 92       	push	r0
 38e:	cd b7       	in	r28, 0x3d	; 61
 390:	de b7       	in	r29, 0x3e	; 62
unsigned char mode,am_pm;
unsigned char digit;
write_uart_strg("Select mode\n\r 1) 12hr \n\r 2) 24hr");               // mode selection
 392:	87 e9       	ldi	r24, 0x97	; 151
 394:	90 e0       	ldi	r25, 0x00	; 0
 396:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
mode=read_uart();
 39a:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 39e:	89 83       	std	Y+1, r24	; 0x01
switch(mode)
 3a0:	89 81       	ldd	r24, Y+1	; 0x01
 3a2:	88 2f       	mov	r24, r24
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	81 33       	cpi	r24, 0x31	; 49
 3a8:	91 05       	cpc	r25, r1
 3aa:	21 f0       	breq	.+8      	; 0x3b4 <write_hour+0x2e>
 3ac:	82 33       	cpi	r24, 0x32	; 50
 3ae:	91 05       	cpc	r25, r1
 3b0:	c9 f1       	breq	.+114    	; 0x424 <write_hour+0x9e>
 3b2:	59 c0       	rjmp	.+178    	; 0x466 <write_hour+0xe0>
{
case '1':                                                             //12 hr mode write hr value
write_uart_strg("\n\rEnter hr");
 3b4:	88 eb       	ldi	r24, 0xB8	; 184
 3b6:	90 e0       	ldi	r25, 0x00	; 0
 3b8:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
digit=(read_uart()-48);
 3bc:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 3c0:	80 53       	subi	r24, 0x30	; 48
 3c2:	8a 83       	std	Y+2, r24	; 0x02
input_time.time[2]=digit<<4;
 3c4:	8a 81       	ldd	r24, Y+2	; 0x02
 3c6:	82 95       	swap	r24
 3c8:	80 7f       	andi	r24, 0xF0	; 240
 3ca:	80 93 2c 01 	sts	0x012C, r24
digit=(read_uart()-48);
 3ce:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 3d2:	80 53       	subi	r24, 0x30	; 48
 3d4:	8a 83       	std	Y+2, r24	; 0x02
input_time.time[2]|=digit;
 3d6:	90 91 2c 01 	lds	r25, 0x012C
 3da:	8a 81       	ldd	r24, Y+2	; 0x02
 3dc:	89 2b       	or	r24, r25
 3de:	80 93 2c 01 	sts	0x012C, r24
input_time.time[2]&=0x4F;
 3e2:	80 91 2c 01 	lds	r24, 0x012C
 3e6:	8f 74       	andi	r24, 0x4F	; 79
 3e8:	80 93 2c 01 	sts	0x012C, r24

write_uart_strg("\n\rEnter \n\r1.am\n\r 2.pm ");                    //select am or pm
 3ec:	83 ec       	ldi	r24, 0xC3	; 195
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
am_pm=read_uart();
 3f4:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 3f8:	8b 83       	std	Y+3, r24	; 0x03

if(am_pm=='1')                                                      //if am selected clearing am bit and 12hr mode bit of hr reg value(bit 5&6)
 3fa:	8b 81       	ldd	r24, Y+3	; 0x03
 3fc:	81 33       	cpi	r24, 0x31	; 49
 3fe:	29 f4       	brne	.+10     	; 0x40a <write_hour+0x84>
input_time.time[2]|=0x40;
 400:	80 91 2c 01 	lds	r24, 0x012C
 404:	80 64       	ori	r24, 0x40	; 64
 406:	80 93 2c 01 	sts	0x012C, r24
if(am_pm=='2')                                                     //if pm selected setting the pm bit and 12hr mode bit(bit 5&6)
 40a:	8b 81       	ldd	r24, Y+3	; 0x03
 40c:	82 33       	cpi	r24, 0x32	; 50
 40e:	29 f4       	brne	.+10     	; 0x41a <write_hour+0x94>
input_time.time[2]|=0x60;
 410:	80 91 2c 01 	lds	r24, 0x012C
 414:	80 66       	ori	r24, 0x60	; 96
 416:	80 93 2c 01 	sts	0x012C, r24

TWI_send(input_time.time[2]);                                     //write hr reg
 41a:	80 91 2c 01 	lds	r24, 0x012C
 41e:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
break;	
 422:	21 c0       	rjmp	.+66     	; 0x466 <write_hour+0xe0>
 
case '2':                                                        //selected 24 hr mode
write_uart_strg("\n\rEnter hr");
 424:	88 eb       	ldi	r24, 0xB8	; 184
 426:	90 e0       	ldi	r25, 0x00	; 0
 428:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
digit=(read_uart()-48);                                          //read the hr value
 42c:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 430:	80 53       	subi	r24, 0x30	; 48
 432:	8a 83       	std	Y+2, r24	; 0x02
input_time.time[2]=digit<<4;
 434:	8a 81       	ldd	r24, Y+2	; 0x02
 436:	82 95       	swap	r24
 438:	80 7f       	andi	r24, 0xF0	; 240
 43a:	80 93 2c 01 	sts	0x012C, r24
digit=(read_uart()-48);
 43e:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 442:	80 53       	subi	r24, 0x30	; 48
 444:	8a 83       	std	Y+2, r24	; 0x02
input_time.time[2]|=digit;
 446:	90 91 2c 01 	lds	r25, 0x012C
 44a:	8a 81       	ldd	r24, Y+2	; 0x02
 44c:	89 2b       	or	r24, r25
 44e:	80 93 2c 01 	sts	0x012C, r24
input_time.time[2]&=0x3F;                                        // clearing the 24hr mode bit(bit6)
 452:	80 91 2c 01 	lds	r24, 0x012C
 456:	8f 73       	andi	r24, 0x3F	; 63
 458:	80 93 2c 01 	sts	0x012C, r24

TWI_send(input_time.time[2]);                                   //write hr register of RTC
 45c:	80 91 2c 01 	lds	r24, 0x012C
 460:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
break;	
 464:	00 00       	nop
}

	
}
 466:	0f 90       	pop	r0
 468:	0f 90       	pop	r0
 46a:	0f 90       	pop	r0
 46c:	cf 91       	pop	r28
 46e:	df 91       	pop	r29
 470:	08 95       	ret

00000472 <Write_time>:
void Write_time()                   //RTC time write
{
 472:	df 93       	push	r29
 474:	cf 93       	push	r28
 476:	00 d0       	rcall	.+0      	; 0x478 <Write_time+0x6>
 478:	cd b7       	in	r28, 0x3d	; 61
 47a:	de b7       	in	r29, 0x3e	; 62
	char i=0;                       //variable for loop iteration
 47c:	19 82       	std	Y+1, r1	; 0x01
	unsigned char digit;            //variable to store the digits of sec and min value
	
	while(i<3)                      //loop to enter the sec,min,hr to input time[3]
 47e:	37 c0       	rjmp	.+110    	; 0x4ee <Write_time+0x7c>
	{
    if(i==2)
 480:	89 81       	ldd	r24, Y+1	; 0x01
 482:	82 30       	cpi	r24, 0x02	; 2
 484:	31 f4       	brne	.+12     	; 0x492 <Write_time+0x20>
	{
	write_hour();                   //hr register is written in write_hr fn 
 486:	0e 94 c3 01 	call	0x386	; 0x386 <write_hour>
	i++;	
 48a:	89 81       	ldd	r24, Y+1	; 0x01
 48c:	8f 5f       	subi	r24, 0xFF	; 255
 48e:	89 83       	std	Y+1, r24	; 0x01
 490:	2e c0       	rjmp	.+92     	; 0x4ee <Write_time+0x7c>
	}
	
	else                          //writes second and min reg
	{
	digit=(read_uart()-48);
 492:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 496:	80 53       	subi	r24, 0x30	; 48
 498:	8a 83       	std	Y+2, r24	; 0x02
	input_time.time[i]=digit<<4;
 49a:	89 81       	ldd	r24, Y+1	; 0x01
 49c:	88 2f       	mov	r24, r24
 49e:	90 e0       	ldi	r25, 0x00	; 0
 4a0:	2a 81       	ldd	r18, Y+2	; 0x02
 4a2:	22 95       	swap	r18
 4a4:	20 7f       	andi	r18, 0xF0	; 240
 4a6:	86 5d       	subi	r24, 0xD6	; 214
 4a8:	9e 4f       	sbci	r25, 0xFE	; 254
 4aa:	fc 01       	movw	r30, r24
 4ac:	20 83       	st	Z, r18
	digit=(read_uart()-48);
 4ae:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 4b2:	80 53       	subi	r24, 0x30	; 48
 4b4:	8a 83       	std	Y+2, r24	; 0x02
	input_time.time[i]|=digit;
 4b6:	89 81       	ldd	r24, Y+1	; 0x01
 4b8:	88 2f       	mov	r24, r24
 4ba:	90 e0       	ldi	r25, 0x00	; 0
 4bc:	29 81       	ldd	r18, Y+1	; 0x01
 4be:	22 2f       	mov	r18, r18
 4c0:	30 e0       	ldi	r19, 0x00	; 0
 4c2:	26 5d       	subi	r18, 0xD6	; 214
 4c4:	3e 4f       	sbci	r19, 0xFE	; 254
 4c6:	f9 01       	movw	r30, r18
 4c8:	30 81       	ld	r19, Z
 4ca:	2a 81       	ldd	r18, Y+2	; 0x02
 4cc:	23 2b       	or	r18, r19
 4ce:	86 5d       	subi	r24, 0xD6	; 214
 4d0:	9e 4f       	sbci	r25, 0xFE	; 254
 4d2:	fc 01       	movw	r30, r24
 4d4:	20 83       	st	Z, r18
	TWI_send(input_time.time[i]);
 4d6:	89 81       	ldd	r24, Y+1	; 0x01
 4d8:	88 2f       	mov	r24, r24
 4da:	90 e0       	ldi	r25, 0x00	; 0
 4dc:	86 5d       	subi	r24, 0xD6	; 214
 4de:	9e 4f       	sbci	r25, 0xFE	; 254
 4e0:	fc 01       	movw	r30, r24
 4e2:	80 81       	ld	r24, Z
 4e4:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
	i++;	
 4e8:	89 81       	ldd	r24, Y+1	; 0x01
 4ea:	8f 5f       	subi	r24, 0xFF	; 255
 4ec:	89 83       	std	Y+1, r24	; 0x01
void Write_time()                   //RTC time write
{
	char i=0;                       //variable for loop iteration
	unsigned char digit;            //variable to store the digits of sec and min value
	
	while(i<3)                      //loop to enter the sec,min,hr to input time[3]
 4ee:	89 81       	ldd	r24, Y+1	; 0x01
 4f0:	83 30       	cpi	r24, 0x03	; 3
 4f2:	30 f2       	brcs	.-116    	; 0x480 <Write_time+0xe>
	TWI_send(input_time.time[i]);
	i++;	
	}
	
	}
}
 4f4:	0f 90       	pop	r0
 4f6:	0f 90       	pop	r0
 4f8:	cf 91       	pop	r28
 4fa:	df 91       	pop	r29
 4fc:	08 95       	ret

000004fe <Write_date>:


void Write_date()                        //RTC write date
{
 4fe:	df 93       	push	r29
 500:	cf 93       	push	r28
 502:	00 d0       	rcall	.+0      	; 0x504 <Write_date+0x6>
 504:	cd b7       	in	r28, 0x3d	; 61
 506:	de b7       	in	r29, 0x3e	; 62
	char i=0;
 508:	19 82       	std	Y+1, r1	; 0x01
	unsigned char digit;
	while(i<4)
 50a:	2e c0       	rjmp	.+92     	; 0x568 <Write_date+0x6a>
	{
	digit=(read_uart()-48);
 50c:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 510:	80 53       	subi	r24, 0x30	; 48
 512:	8a 83       	std	Y+2, r24	; 0x02
	input_time.date[i]=digit<<4;
 514:	89 81       	ldd	r24, Y+1	; 0x01
 516:	88 2f       	mov	r24, r24
 518:	90 e0       	ldi	r25, 0x00	; 0
 51a:	2a 81       	ldd	r18, Y+2	; 0x02
 51c:	22 95       	swap	r18
 51e:	20 7f       	andi	r18, 0xF0	; 240
 520:	83 5d       	subi	r24, 0xD3	; 211
 522:	9e 4f       	sbci	r25, 0xFE	; 254
 524:	fc 01       	movw	r30, r24
 526:	20 83       	st	Z, r18
	digit=(read_uart()-48);
 528:	0e 94 03 04 	call	0x806	; 0x806 <read_uart>
 52c:	80 53       	subi	r24, 0x30	; 48
 52e:	8a 83       	std	Y+2, r24	; 0x02
	input_time.date[i]|=digit;
 530:	89 81       	ldd	r24, Y+1	; 0x01
 532:	88 2f       	mov	r24, r24
 534:	90 e0       	ldi	r25, 0x00	; 0
 536:	29 81       	ldd	r18, Y+1	; 0x01
 538:	22 2f       	mov	r18, r18
 53a:	30 e0       	ldi	r19, 0x00	; 0
 53c:	23 5d       	subi	r18, 0xD3	; 211
 53e:	3e 4f       	sbci	r19, 0xFE	; 254
 540:	f9 01       	movw	r30, r18
 542:	30 81       	ld	r19, Z
 544:	2a 81       	ldd	r18, Y+2	; 0x02
 546:	23 2b       	or	r18, r19
 548:	83 5d       	subi	r24, 0xD3	; 211
 54a:	9e 4f       	sbci	r25, 0xFE	; 254
 54c:	fc 01       	movw	r30, r24
 54e:	20 83       	st	Z, r18
	TWI_send(input_time.date[i]);
 550:	89 81       	ldd	r24, Y+1	; 0x01
 552:	88 2f       	mov	r24, r24
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	83 5d       	subi	r24, 0xD3	; 211
 558:	9e 4f       	sbci	r25, 0xFE	; 254
 55a:	fc 01       	movw	r30, r24
 55c:	80 81       	ld	r24, Z
 55e:	0e 94 9e 03 	call	0x73c	; 0x73c <TWI_send>
	i++;
 562:	89 81       	ldd	r24, Y+1	; 0x01
 564:	8f 5f       	subi	r24, 0xFF	; 255
 566:	89 83       	std	Y+1, r24	; 0x01

void Write_date()                        //RTC write date
{
	char i=0;
	unsigned char digit;
	while(i<4)
 568:	89 81       	ldd	r24, Y+1	; 0x01
 56a:	84 30       	cpi	r24, 0x04	; 4
 56c:	78 f2       	brcs	.-98     	; 0x50c <Write_date+0xe>
	digit=(read_uart()-48);
	input_time.date[i]|=digit;
	TWI_send(input_time.date[i]);
	i++;
	}
}
 56e:	0f 90       	pop	r0
 570:	0f 90       	pop	r0
 572:	cf 91       	pop	r28
 574:	df 91       	pop	r29
 576:	08 95       	ret

00000578 <Read_date>:

void Read_date()
{
 578:	0f 93       	push	r16
 57a:	1f 93       	push	r17
 57c:	df 93       	push	r29
 57e:	cf 93       	push	r28
 580:	0f 92       	push	r0
 582:	cd b7       	in	r28, 0x3d	; 61
 584:	de b7       	in	r29, 0x3e	; 62
	unsigned char i=0;
 586:	19 82       	std	Y+1, r1	; 0x01
	while(i<4)
 588:	1d c0       	rjmp	.+58     	; 0x5c4 <Read_date+0x4c>
	{
		if(i==3)
 58a:	89 81       	ldd	r24, Y+1	; 0x01
 58c:	83 30       	cpi	r24, 0x03	; 3
 58e:	61 f4       	brne	.+24     	; 0x5a8 <Read_date+0x30>
		current_time.date[i]=TWI_read_nack();
 590:	89 81       	ldd	r24, Y+1	; 0x01
 592:	08 2f       	mov	r16, r24
 594:	10 e0       	ldi	r17, 0x00	; 0
 596:	0e 94 64 03 	call	0x6c8	; 0x6c8 <TWI_read_nack>
 59a:	28 2f       	mov	r18, r24
 59c:	c8 01       	movw	r24, r16
 59e:	8c 5c       	subi	r24, 0xCC	; 204
 5a0:	9e 4f       	sbci	r25, 0xFE	; 254
 5a2:	fc 01       	movw	r30, r24
 5a4:	20 83       	st	Z, r18
 5a6:	0b c0       	rjmp	.+22     	; 0x5be <Read_date+0x46>
		else
		current_time.date[i]=TWI_read_ack();
 5a8:	89 81       	ldd	r24, Y+1	; 0x01
 5aa:	08 2f       	mov	r16, r24
 5ac:	10 e0       	ldi	r17, 0x00	; 0
 5ae:	0e 94 49 03 	call	0x692	; 0x692 <TWI_read_ack>
 5b2:	28 2f       	mov	r18, r24
 5b4:	c8 01       	movw	r24, r16
 5b6:	8c 5c       	subi	r24, 0xCC	; 204
 5b8:	9e 4f       	sbci	r25, 0xFE	; 254
 5ba:	fc 01       	movw	r30, r24
 5bc:	20 83       	st	Z, r18
		i++;
 5be:	89 81       	ldd	r24, Y+1	; 0x01
 5c0:	8f 5f       	subi	r24, 0xFF	; 255
 5c2:	89 83       	std	Y+1, r24	; 0x01
}

void Read_date()
{
	unsigned char i=0;
	while(i<4)
 5c4:	89 81       	ldd	r24, Y+1	; 0x01
 5c6:	84 30       	cpi	r24, 0x04	; 4
 5c8:	00 f3       	brcs	.-64     	; 0x58a <Read_date+0x12>
		current_time.date[i]=TWI_read_nack();
		else
		current_time.date[i]=TWI_read_ack();
		i++;
	}
	decode_time();
 5ca:	0e 94 0f 01 	call	0x21e	; 0x21e <decode_time>
}
 5ce:	0f 90       	pop	r0
 5d0:	cf 91       	pop	r28
 5d2:	df 91       	pop	r29
 5d4:	1f 91       	pop	r17
 5d6:	0f 91       	pop	r16
 5d8:	08 95       	ret

000005da <Read_time>:


void Read_time()               //reads the value in RTC reg
{
 5da:	0f 93       	push	r16
 5dc:	1f 93       	push	r17
 5de:	df 93       	push	r29
 5e0:	cf 93       	push	r28
 5e2:	0f 92       	push	r0
 5e4:	cd b7       	in	r28, 0x3d	; 61
 5e6:	de b7       	in	r29, 0x3e	; 62
unsigned char i=0;
 5e8:	19 82       	std	Y+1, r1	; 0x01
while(i<3)	
 5ea:	1d c0       	rjmp	.+58     	; 0x626 <Read_time+0x4c>
{
if(i==2)
 5ec:	89 81       	ldd	r24, Y+1	; 0x01
 5ee:	82 30       	cpi	r24, 0x02	; 2
 5f0:	61 f4       	brne	.+24     	; 0x60a <Read_time+0x30>
current_time.time[i]=TWI_read_ack();
 5f2:	89 81       	ldd	r24, Y+1	; 0x01
 5f4:	08 2f       	mov	r16, r24
 5f6:	10 e0       	ldi	r17, 0x00	; 0
 5f8:	0e 94 49 03 	call	0x692	; 0x692 <TWI_read_ack>
 5fc:	28 2f       	mov	r18, r24
 5fe:	c8 01       	movw	r24, r16
 600:	8f 5c       	subi	r24, 0xCF	; 207
 602:	9e 4f       	sbci	r25, 0xFE	; 254
 604:	fc 01       	movw	r30, r24
 606:	20 83       	st	Z, r18
 608:	0b c0       	rjmp	.+22     	; 0x620 <Read_time+0x46>
else
current_time.time[i]=TWI_read_ack();	
 60a:	89 81       	ldd	r24, Y+1	; 0x01
 60c:	08 2f       	mov	r16, r24
 60e:	10 e0       	ldi	r17, 0x00	; 0
 610:	0e 94 49 03 	call	0x692	; 0x692 <TWI_read_ack>
 614:	28 2f       	mov	r18, r24
 616:	c8 01       	movw	r24, r16
 618:	8f 5c       	subi	r24, 0xCF	; 207
 61a:	9e 4f       	sbci	r25, 0xFE	; 254
 61c:	fc 01       	movw	r30, r24
 61e:	20 83       	st	Z, r18
i++;
 620:	89 81       	ldd	r24, Y+1	; 0x01
 622:	8f 5f       	subi	r24, 0xFF	; 255
 624:	89 83       	std	Y+1, r24	; 0x01


void Read_time()               //reads the value in RTC reg
{
unsigned char i=0;
while(i<3)	
 626:	89 81       	ldd	r24, Y+1	; 0x01
 628:	83 30       	cpi	r24, 0x03	; 3
 62a:	00 f3       	brcs	.-64     	; 0x5ec <Read_time+0x12>
current_time.time[i]=TWI_read_ack();
else
current_time.time[i]=TWI_read_ack();	
i++;
}
Read_date();
 62c:	0e 94 bc 02 	call	0x578	; 0x578 <Read_date>
}
 630:	0f 90       	pop	r0
 632:	cf 91       	pop	r28
 634:	df 91       	pop	r29
 636:	1f 91       	pop	r17
 638:	0f 91       	pop	r16
 63a:	08 95       	ret

0000063c <main>:


/*****************main function****************************************/

int main(void)
{
 63c:	df 93       	push	r29
 63e:	cf 93       	push	r28
 640:	cd b7       	in	r28, 0x3d	; 61
 642:	de b7       	in	r29, 0x3e	; 62
   TWI_init();
 644:	0e 94 3d 03 	call	0x67a	; 0x67a <TWI_init>
   uart_initialize();
 648:	0e 94 b9 03 	call	0x772	; 0x772 <uart_initialize>
      TWI_start();
 64c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <TWI_start>
   RTC_write_mode(); 
 650:	0e 94 a6 01 	call	0x34c	; 0x34c <RTC_write_mode>
   write_uart_strg("Enter the time seconds & minutes (SS:MM)");
 654:	8a ed       	ldi	r24, 0xDA	; 218
 656:	90 e0       	ldi	r25, 0x00	; 0
 658:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
   Write_time();
 65c:	0e 94 39 02 	call	0x472	; 0x472 <Write_time>
   write_uart_strg("Enter the Day (01-07) & Date (DDMMYY)");
 660:	83 e0       	ldi	r24, 0x03	; 3
 662:	91 e0       	ldi	r25, 0x01	; 1
 664:	0e 94 19 04 	call	0x832	; 0x832 <write_uart_strg>
   Write_date();
 668:	0e 94 7f 02 	call	0x4fe	; 0x4fe <Write_date>
   
   
   
    while (1) 
    {
	TWI_stop();
 66c:	0e 94 92 03 	call	0x724	; 0x724 <TWI_stop>
	RTC_write_pointer_read_mode();
 670:	0e 94 b3 01 	call	0x366	; 0x366 <RTC_write_pointer_read_mode>
	Read_time();	
 674:	0e 94 ed 02 	call	0x5da	; 0x5da <Read_time>
    }
 678:	f9 cf       	rjmp	.-14     	; 0x66c <main+0x30>

0000067a <TWI_init>:

#include <avr/io.h>
void TWI_init()                                      //TWI initialization with desired SCL frequency
{
 67a:	df 93       	push	r29
 67c:	cf 93       	push	r28
 67e:	cd b7       	in	r28, 0x3d	; 61
 680:	de b7       	in	r29, 0x3e	; 62
	TWBR=32;
 682:	80 e2       	ldi	r24, 0x20	; 32
 684:	90 e0       	ldi	r25, 0x00	; 0
 686:	20 e2       	ldi	r18, 0x20	; 32
 688:	fc 01       	movw	r30, r24
 68a:	20 83       	st	Z, r18
	
}
 68c:	cf 91       	pop	r28
 68e:	df 91       	pop	r29
 690:	08 95       	ret

00000692 <TWI_read_ack>:

unsigned char TWI_read_ack()                        //TWI recieve data with ack
{
 692:	df 93       	push	r29
 694:	cf 93       	push	r28
 696:	0f 92       	push	r0
 698:	cd b7       	in	r28, 0x3d	; 61
 69a:	de b7       	in	r29, 0x3e	; 62
	unsigned char data;
	TWCR=0xC4;                                          //clear flag and TWIE set
 69c:	86 e5       	ldi	r24, 0x56	; 86
 69e:	90 e0       	ldi	r25, 0x00	; 0
 6a0:	24 ec       	ldi	r18, 0xC4	; 196
 6a2:	fc 01       	movw	r30, r24
 6a4:	20 83       	st	Z, r18
	while(!(TWCR&(1<<TWINT)));                          //wait until the flag sets ie end of recieve condition
 6a6:	00 00       	nop
 6a8:	86 e5       	ldi	r24, 0x56	; 86
 6aa:	90 e0       	ldi	r25, 0x00	; 0
 6ac:	fc 01       	movw	r30, r24
 6ae:	80 81       	ld	r24, Z
 6b0:	88 23       	and	r24, r24
 6b2:	d4 f7       	brge	.-12     	; 0x6a8 <TWI_read_ack+0x16>
	data=TWDR;                                           //read data
 6b4:	83 e2       	ldi	r24, 0x23	; 35
 6b6:	90 e0       	ldi	r25, 0x00	; 0
 6b8:	fc 01       	movw	r30, r24
 6ba:	80 81       	ld	r24, Z
 6bc:	89 83       	std	Y+1, r24	; 0x01
	return data;
 6be:	89 81       	ldd	r24, Y+1	; 0x01
}
 6c0:	0f 90       	pop	r0
 6c2:	cf 91       	pop	r28
 6c4:	df 91       	pop	r29
 6c6:	08 95       	ret

000006c8 <TWI_read_nack>:

unsigned char TWI_read_nack()                    //TWI recive last byte with NACK
{
 6c8:	df 93       	push	r29
 6ca:	cf 93       	push	r28
 6cc:	0f 92       	push	r0
 6ce:	cd b7       	in	r28, 0x3d	; 61
 6d0:	de b7       	in	r29, 0x3e	; 62
	unsigned char data;
	TWCR=0x84;                                 //clear flag and TWIE set
 6d2:	86 e5       	ldi	r24, 0x56	; 86
 6d4:	90 e0       	ldi	r25, 0x00	; 0
 6d6:	24 e8       	ldi	r18, 0x84	; 132
 6d8:	fc 01       	movw	r30, r24
 6da:	20 83       	st	Z, r18
	while(!(TWCR&(1<<TWINT)));                 //wait until the flag sets ie end of recieve condition
 6dc:	00 00       	nop
 6de:	86 e5       	ldi	r24, 0x56	; 86
 6e0:	90 e0       	ldi	r25, 0x00	; 0
 6e2:	fc 01       	movw	r30, r24
 6e4:	80 81       	ld	r24, Z
 6e6:	88 23       	and	r24, r24
 6e8:	d4 f7       	brge	.-12     	; 0x6de <TWI_read_nack+0x16>
	data=TWDR;                                 //read data
 6ea:	83 e2       	ldi	r24, 0x23	; 35
 6ec:	90 e0       	ldi	r25, 0x00	; 0
 6ee:	fc 01       	movw	r30, r24
 6f0:	80 81       	ld	r24, Z
 6f2:	89 83       	std	Y+1, r24	; 0x01
	return data;
 6f4:	89 81       	ldd	r24, Y+1	; 0x01
}
 6f6:	0f 90       	pop	r0
 6f8:	cf 91       	pop	r28
 6fa:	df 91       	pop	r29
 6fc:	08 95       	ret

000006fe <TWI_start>:

void TWI_start()                                    //generate a start condition on the TWI bus
{
 6fe:	df 93       	push	r29
 700:	cf 93       	push	r28
 702:	cd b7       	in	r28, 0x3d	; 61
 704:	de b7       	in	r29, 0x3e	; 62
	TWCR=0xA4;                                         //value to be loaded to clear TWINT flag and start START condition
 706:	86 e5       	ldi	r24, 0x56	; 86
 708:	90 e0       	ldi	r25, 0x00	; 0
 70a:	24 ea       	ldi	r18, 0xA4	; 164
 70c:	fc 01       	movw	r30, r24
 70e:	20 83       	st	Z, r18
	while(!(TWCR&(1<<TWINT)));                         //wait until the flag sets ie end of start condition
 710:	00 00       	nop
 712:	86 e5       	ldi	r24, 0x56	; 86
 714:	90 e0       	ldi	r25, 0x00	; 0
 716:	fc 01       	movw	r30, r24
 718:	80 81       	ld	r24, Z
 71a:	88 23       	and	r24, r24
 71c:	d4 f7       	brge	.-12     	; 0x712 <TWI_start+0x14>
}
 71e:	cf 91       	pop	r28
 720:	df 91       	pop	r29
 722:	08 95       	ret

00000724 <TWI_stop>:

void TWI_stop()
{
 724:	df 93       	push	r29
 726:	cf 93       	push	r28
 728:	cd b7       	in	r28, 0x3d	; 61
 72a:	de b7       	in	r29, 0x3e	; 62
	TWCR=0x94;                                         //value to be loaded to clear TWINT flag and start STOP condition
 72c:	86 e5       	ldi	r24, 0x56	; 86
 72e:	90 e0       	ldi	r25, 0x00	; 0
 730:	24 e9       	ldi	r18, 0x94	; 148
 732:	fc 01       	movw	r30, r24
 734:	20 83       	st	Z, r18
	//while(!(TWCR&(1<<TWINT)));                         //wait until the flag sets ie end of stop condition
}
 736:	cf 91       	pop	r28
 738:	df 91       	pop	r29
 73a:	08 95       	ret

0000073c <TWI_send>:

void TWI_send(unsigned char data)                 //sends data into the slave
{
 73c:	df 93       	push	r29
 73e:	cf 93       	push	r28
 740:	0f 92       	push	r0
 742:	cd b7       	in	r28, 0x3d	; 61
 744:	de b7       	in	r29, 0x3e	; 62
 746:	89 83       	std	Y+1, r24	; 0x01
	TWDR=data;                                        //data to be sent
 748:	83 e2       	ldi	r24, 0x23	; 35
 74a:	90 e0       	ldi	r25, 0x00	; 0
 74c:	29 81       	ldd	r18, Y+1	; 0x01
 74e:	fc 01       	movw	r30, r24
 750:	20 83       	st	Z, r18
	TWCR=0x84;                                        //interrupt flag is cleared
 752:	86 e5       	ldi	r24, 0x56	; 86
 754:	90 e0       	ldi	r25, 0x00	; 0
 756:	24 e8       	ldi	r18, 0x84	; 132
 758:	fc 01       	movw	r30, r24
 75a:	20 83       	st	Z, r18
	while(!(TWCR&(1<<TWINT)));	                      //wait until flag sets
 75c:	00 00       	nop
 75e:	86 e5       	ldi	r24, 0x56	; 86
 760:	90 e0       	ldi	r25, 0x00	; 0
 762:	fc 01       	movw	r30, r24
 764:	80 81       	ld	r24, Z
 766:	88 23       	and	r24, r24
 768:	d4 f7       	brge	.-12     	; 0x75e <TWI_send+0x22>
	//TWCR=0x84;
 76a:	0f 90       	pop	r0
 76c:	cf 91       	pop	r28
 76e:	df 91       	pop	r29
 770:	08 95       	ret

00000772 <uart_initialize>:
#include <avr/io.h>
void uart_initialize()
{
 772:	df 93       	push	r29
 774:	cf 93       	push	r28
 776:	00 d0       	rcall	.+0      	; 0x778 <uart_initialize+0x6>
 778:	cd b7       	in	r28, 0x3d	; 61
 77a:	de b7       	in	r29, 0x3e	; 62
	unsigned int baudrate_value=103;
 77c:	87 e6       	ldi	r24, 0x67	; 103
 77e:	90 e0       	ldi	r25, 0x00	; 0
 780:	9a 83       	std	Y+2, r25	; 0x02
 782:	89 83       	std	Y+1, r24	; 0x01
	UBRRL=baudrate_value;                             //Loading the baud rate generator registers
 784:	89 e2       	ldi	r24, 0x29	; 41
 786:	90 e0       	ldi	r25, 0x00	; 0
 788:	29 81       	ldd	r18, Y+1	; 0x01
 78a:	fc 01       	movw	r30, r24
 78c:	20 83       	st	Z, r18
	UBRRH=(baudrate_value>>8);
 78e:	80 e4       	ldi	r24, 0x40	; 64
 790:	90 e0       	ldi	r25, 0x00	; 0
 792:	29 81       	ldd	r18, Y+1	; 0x01
 794:	3a 81       	ldd	r19, Y+2	; 0x02
 796:	23 2f       	mov	r18, r19
 798:	33 27       	eor	r19, r19
 79a:	fc 01       	movw	r30, r24
 79c:	20 83       	st	Z, r18

	UCSRB=(1<<TXEN)|(1<<RXEN);                       //Enabling transmission and reception
 79e:	8a e2       	ldi	r24, 0x2A	; 42
 7a0:	90 e0       	ldi	r25, 0x00	; 0
 7a2:	28 e1       	ldi	r18, 0x18	; 24
 7a4:	fc 01       	movw	r30, r24
 7a6:	20 83       	st	Z, r18

	UCSRC=(1<<URSEL)|(3<<UCSZ0);                    //accessing the UCSRC register and selecting 8 bit data format
 7a8:	80 e4       	ldi	r24, 0x40	; 64
 7aa:	90 e0       	ldi	r25, 0x00	; 0
 7ac:	26 e8       	ldi	r18, 0x86	; 134
 7ae:	fc 01       	movw	r30, r24
 7b0:	20 83       	st	Z, r18
}
 7b2:	0f 90       	pop	r0
 7b4:	0f 90       	pop	r0
 7b6:	cf 91       	pop	r28
 7b8:	df 91       	pop	r29
 7ba:	08 95       	ret

000007bc <write_uart>:
/*transmit a file through UART*/
void write_uart(unsigned char data)
{
 7bc:	df 93       	push	r29
 7be:	cf 93       	push	r28
 7c0:	0f 92       	push	r0
 7c2:	cd b7       	in	r28, 0x3d	; 61
 7c4:	de b7       	in	r29, 0x3e	; 62
 7c6:	89 83       	std	Y+1, r24	; 0x01
	while(!(UCSRA&(1<<UDRE)));
 7c8:	00 00       	nop
 7ca:	8b e2       	ldi	r24, 0x2B	; 43
 7cc:	90 e0       	ldi	r25, 0x00	; 0
 7ce:	fc 01       	movw	r30, r24
 7d0:	80 81       	ld	r24, Z
 7d2:	88 2f       	mov	r24, r24
 7d4:	90 e0       	ldi	r25, 0x00	; 0
 7d6:	80 72       	andi	r24, 0x20	; 32
 7d8:	90 70       	andi	r25, 0x00	; 0
 7da:	00 97       	sbiw	r24, 0x00	; 0
 7dc:	b1 f3       	breq	.-20     	; 0x7ca <write_uart+0xe>
	UDR=data;
 7de:	8c e2       	ldi	r24, 0x2C	; 44
 7e0:	90 e0       	ldi	r25, 0x00	; 0
 7e2:	29 81       	ldd	r18, Y+1	; 0x01
 7e4:	fc 01       	movw	r30, r24
 7e6:	20 83       	st	Z, r18
	while(!(UCSRA&(1<<TXC)));
 7e8:	00 00       	nop
 7ea:	8b e2       	ldi	r24, 0x2B	; 43
 7ec:	90 e0       	ldi	r25, 0x00	; 0
 7ee:	fc 01       	movw	r30, r24
 7f0:	80 81       	ld	r24, Z
 7f2:	88 2f       	mov	r24, r24
 7f4:	90 e0       	ldi	r25, 0x00	; 0
 7f6:	80 74       	andi	r24, 0x40	; 64
 7f8:	90 70       	andi	r25, 0x00	; 0
 7fa:	00 97       	sbiw	r24, 0x00	; 0
 7fc:	b1 f3       	breq	.-20     	; 0x7ea <write_uart+0x2e>
}
 7fe:	0f 90       	pop	r0
 800:	cf 91       	pop	r28
 802:	df 91       	pop	r29
 804:	08 95       	ret

00000806 <read_uart>:
/*receive a file from UART*/
unsigned char read_uart()
{
 806:	df 93       	push	r29
 808:	cf 93       	push	r28
 80a:	0f 92       	push	r0
 80c:	cd b7       	in	r28, 0x3d	; 61
 80e:	de b7       	in	r29, 0x3e	; 62
	unsigned char data;
	while(!(UCSRA&(1<<RXC)));
 810:	00 00       	nop
 812:	8b e2       	ldi	r24, 0x2B	; 43
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	fc 01       	movw	r30, r24
 818:	80 81       	ld	r24, Z
 81a:	88 23       	and	r24, r24
 81c:	d4 f7       	brge	.-12     	; 0x812 <read_uart+0xc>
	data=UDR;
 81e:	8c e2       	ldi	r24, 0x2C	; 44
 820:	90 e0       	ldi	r25, 0x00	; 0
 822:	fc 01       	movw	r30, r24
 824:	80 81       	ld	r24, Z
 826:	89 83       	std	Y+1, r24	; 0x01
	return data;
 828:	89 81       	ldd	r24, Y+1	; 0x01
}
 82a:	0f 90       	pop	r0
 82c:	cf 91       	pop	r28
 82e:	df 91       	pop	r29
 830:	08 95       	ret

00000832 <write_uart_strg>:
/*transmit a string through UART*/
void write_uart_strg(char *ptr)
{
 832:	df 93       	push	r29
 834:	cf 93       	push	r28
 836:	00 d0       	rcall	.+0      	; 0x838 <write_uart_strg+0x6>
 838:	cd b7       	in	r28, 0x3d	; 61
 83a:	de b7       	in	r29, 0x3e	; 62
 83c:	9a 83       	std	Y+2, r25	; 0x02
 83e:	89 83       	std	Y+1, r24	; 0x01
	while(*ptr)
 840:	0b c0       	rjmp	.+22     	; 0x858 <write_uart_strg+0x26>
	{
		write_uart(*ptr);
 842:	89 81       	ldd	r24, Y+1	; 0x01
 844:	9a 81       	ldd	r25, Y+2	; 0x02
 846:	fc 01       	movw	r30, r24
 848:	80 81       	ld	r24, Z
 84a:	0e 94 de 03 	call	0x7bc	; 0x7bc <write_uart>
		ptr++;
 84e:	89 81       	ldd	r24, Y+1	; 0x01
 850:	9a 81       	ldd	r25, Y+2	; 0x02
 852:	01 96       	adiw	r24, 0x01	; 1
 854:	9a 83       	std	Y+2, r25	; 0x02
 856:	89 83       	std	Y+1, r24	; 0x01
	return data;
}
/*transmit a string through UART*/
void write_uart_strg(char *ptr)
{
	while(*ptr)
 858:	89 81       	ldd	r24, Y+1	; 0x01
 85a:	9a 81       	ldd	r25, Y+2	; 0x02
 85c:	fc 01       	movw	r30, r24
 85e:	80 81       	ld	r24, Z
 860:	88 23       	and	r24, r24
 862:	79 f7       	brne	.-34     	; 0x842 <write_uart_strg+0x10>
	{
		write_uart(*ptr);
		ptr++;
	}
}
 864:	0f 90       	pop	r0
 866:	0f 90       	pop	r0
 868:	cf 91       	pop	r28
 86a:	df 91       	pop	r29
 86c:	08 95       	ret

0000086e <__udivmodqi4>:
 86e:	99 1b       	sub	r25, r25
 870:	79 e0       	ldi	r23, 0x09	; 9
 872:	04 c0       	rjmp	.+8      	; 0x87c <__udivmodqi4_ep>

00000874 <__udivmodqi4_loop>:
 874:	99 1f       	adc	r25, r25
 876:	96 17       	cp	r25, r22
 878:	08 f0       	brcs	.+2      	; 0x87c <__udivmodqi4_ep>
 87a:	96 1b       	sub	r25, r22

0000087c <__udivmodqi4_ep>:
 87c:	88 1f       	adc	r24, r24
 87e:	7a 95       	dec	r23
 880:	c9 f7       	brne	.-14     	; 0x874 <__udivmodqi4_loop>
 882:	80 95       	com	r24
 884:	08 95       	ret

00000886 <_exit>:
 886:	f8 94       	cli

00000888 <__stop_program>:
 888:	ff cf       	rjmp	.-2      	; 0x888 <__stop_program>
